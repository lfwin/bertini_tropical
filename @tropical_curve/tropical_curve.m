% TROPICAL_CURVE computes real and complex tropical curves using Bertini
%
% T = TROPICAL_CURVE(options)
%
% Numerically decompose a tropical curve in any number of variables using Bertini.
%
% This code computes both real and complex tropical curves.  By default, it
% computes the real tropical curve.  The curve is automatically decomposed
% when you create an object of this type, assuming that there is a
% |Bertini|
% input file named |input| in the current directory, that it a NID has been
% generated using |tracktype 1|.  Furthermore, to compute the rays for the
% tropical variety at infinity, the curve system should be:
%
% * homogenized, using a variable of name 'h'.
% * patched, using a function of arbitrary name, provided so that the
% homogenized system is square.  This is essentially a linear function of
% all variables, with random (real) coefficients and constant value 1.
%
% Additionally, do not use variables named |t| or |s| in your system, as
% these will be used for the tracking of monodromy loops in the
% calculations.  
%
% Important:
% The output variable is of type tropical_curve, and is a handle.  This
% means that `copying' a curve |C| into |D| by |D = C|  does not actually
% copy the curve C, but the handle.  Hence , modifying C modifies D as
% well.  If you want a genuine COPY of |C|, use |D = copy(C)|.
% 
% Input to this consists of a Bertini |input| file, and a pre-computed
% |witness_data| file, generated by running |Bertini| with |tracktype: 1;|
%
% The constructor method for objects of type |tropical_curve| offers 
% several options:
%
% * |real| - Computes the real tropical curve
% * |complex| - Computes the complex tropical curve.  This is the
% default mode.
% * |input| - followed by a string, the name of the Bertini input
% file containing the curve to be decomposed.  By default, this is
% |input|.
% * All others are passed to the function which actually does the
% decomposition, |decompose_tropical_real_curve| or
% |decomposed_tropical_complex_curve|.  See below.
%
% Arguments passed on:
% 
% * |defaultslicevalue| - positive float, the default value for slicing near
% coordinate axes.  the slice value used is the lesser of (this value, and
% the nearest absolute value of critical points).  the default for this
% setting was arbitrarily chosen to be 0.1.
% * |numsamplepoints| - even integer, determines the number of samples
% taken for monodromy around the coordinate axes.  default is 8.  larger
% problems may require a higher number.
% * |puiseuxthreshold| - computed puiseux series coefficients less than this
% tolerance are considered zero.
% * |intersectionthreshold| - coordinates of intersection points less than this
% tolerance are considered zero.
% * |intersectionuniquethreshold| - intersection points are unique if
% separated by this distance or more.
% * |cauchyuniquethreshold| - points on cauchy loops are unique if separated
% by more than this distance.
%
% Notes:
% * The constructor function automatically saves a copy of the tropical curve to
% the disk with a timestamp.  
% * Additionally, this function works in
% temporary directory, which can be safely deleted after
% decomposition is complete.
% * The decomposition functions save computed data where possible,
% in case a step fails or produces undesirable results.  For
% example, the intersection points are saved, so that if a critical
% point computation is not to your satisfaction, and you wish to
% re-compute the critical points, the intersection points will be
% re-loaded from disk.  If you want to start all the way over,
% simply delete the folder.  Otherwise, delete the |.mat| files in
% the created temp folder, and the data will be re-created using
% the current Bertini settings.  
% * One more note regarding the re-use of data.  Incremental saves
% were added because sometimes different parts of the computation
% will fail or struggle, and you don't want to start all the way
% over.  For example, the regeneration for critical points can take
% a long time, and you certainly don't want to have to re-run this
% every time you decompose the curve.  So if a later step fails,
% simply change Bertini settings in the input file, and re-run the
% tropical decomposition.  The earlier data is saved in place, and
% re-loaded.
% 
% |tropical_curve| also takes any command-line options for the
% |decompose_tropical_real_curve| and |decompose_tropical_complex_curve|
% functions, provided as a part of this package, and briefly documented above.
% See their documentation for
% a list of options you can pass to it. 
% 
% *Note:* The decomposed tropical curve is automatically saved with a time stamp to
% the current directory when completed.
%
% Comments and questions are welcomed, as are any suggestions on making
% this code more usable and general
%
%  
% copyright 2015, 2016 Daniel Brake
% University of Notre Dame
% Applied and Computational Mathematics and Statistics
% danielthebrake@gmail.com
%
%  Bertini (TM) is a registered trademark.
%
%     This file is part of Bertini_tropical.
%
%     Bertini_tropical is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
% 
%     Bertini_tropical is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
% 
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
% See also DECOMPOSE_TROPICAL_REAL_CURVE, DECOMPOSE_TROPICAL_COMPLEX_CURVE.


%% TROPICAL_CURVE
classdef tropical_curve < handle & matlab.mixin.Copyable


	%% properties
	properties
		is_real; %boolean indicating whether the curve is the real or complex tropical.
		
		is_homogenized; %boolean indicating whether is homogenized
		homogenizing_variable; % the name of the homogenizing variable
		
		
		% The computed rays are the valuations of Puiseux series
		% at intersections with coordinate hyperplanes
		rays; % The rays of the tropical curve
		
		% The multiplicities are the number of times a ray appears,
		% loosely.  
		%
		% More accurately, the multiplicity of a ray is the number of times
		% it appears, with rays which can be reduced by a GCD having its
		% multiplicity multiplied by the GCD.
		multiplicities; %Multiplicities of the rays
		
		

		
		variables; % The variables in the problem.
		curve_system; % The system defining the curve.
		subfunctions; % Subfunctions in the system
		system_name; % The name of the system
		
		% Computed data which is not necessarily part of the 
		% tropical curve, but was computed during the decomposition.
		% Examples of this are the cauchy paths around coordinate
		% intersection points.
		aux_data; %Computed meta-data
	end
	
	
	%% methods
	methods
		
		%% CONSTRUCTOR
		function this = tropical_curve(varargin)
		% Constructor for tropical curve.  Automatically calls Bertini.
		%
		% Decomposes the tropical curve using Numerical Algebraic Geometry.
		% 
		% The constructor offers several options:
		%
		% * |real| - Computes the real tropical curve
		% * |complex| - Computes the complex tropical curve.  This is the
		% default mode.
		% * |input| - followed by a string, the name of the Bertini input
		% file containing the curve to be decomposed.  By default, this is
		% |input|.
		% * All others are passed to the function which actually does the
		% decomposition, |decompose_tropical_real_curve| or
		% |decomposed_tropical_complex_curve|.  See their documentation.
		%
		% Arguments passed on:
		% 
		% * |defaultslicevalue| - positive float, the default value for slicing near
		% coordinate axes.  the slice value used is the lesser of (this value, and
		% the nearest absolute value of critical points).  the default for this
		% setting was arbitrarily chosen to be 0.1.
		% * |numsamplepoints| - even integer, determines the number of samples
		% taken for monodromy around the coordinate axes.  default is 8.  larger
		% problems may require a higher number.
		% * |puiseuxthreshold| - computed puiseux series coefficients less than this
		% tolerance are considered zero.
		% * |intersectionthreshold| - coordinates of intersection points less than this
		% tolerance are considered zero.
		% * |intersectionuniquethreshold| - intersection points are unique if
		% separated by this distance or more.
		% * |cauchyuniquethreshold| - points on cauchy loops are unique if separated
		% by more than this distance.
		%
		% Notes:
		% * This function automatically saves a copy of the tropical curve to
		% the disk with a timestamp.  
		% * Additionally, this function works in
		% temporary directory, which can be safely deleted after
		% decomposition is complete.
		% * The decomposition functions save computed data where possible,
		% in case a step fails or produces undesirable results.  For
		% example, the intersection points are saved, so that if a critical
		% point computation is not to your satisfaction, and you wish to
		% re-compute the critical points, the intersection points will be
		% re-loaded from disk.  If you want to start all the way over,
		% simply delete the folder.  Otherwise, delete the |.mat| files in
		% the created temp folder, and the data will be re-created using
		% the current Bertini settings.  
		% * One more note regarding the re-use of data.  Incremental saves
		% were added because sometimes different parts of the computation
		% will fail or struggle, and you don't want to start all the way
		% over.  For example, the regeneration for critical points can take
		% a long time, and you certainly don't want to have to re-run this
		% every time you decompose the curve.  So if a later step fails,
		% simply change Bertini settings in the input file, and re-run the
		% tropical decomposition.  The earlier data is saved in place, and
		% re-loaded.
		
			this.is_real = false;
			option_counter = 0;
			inputfilename = 'input';
			
			[~, this.system_name, ~] = fileparts(pwd);
			
			this.system_name = this.system_name(~isspace(this.system_name));
			
			pass_through_args = {};
			while option_counter < length(varargin)
				option_counter = option_counter+1;
				curr_opt_name = varargin{option_counter};
				
				switch curr_opt_name
					case 'real'
						this.is_real = true;
						
					case 'complex'
						this.is_real = false;
						
					case 'input'
						option_counter = option_counter+1;
						inputfilename = varargin{option_counter};
						
					otherwise
						pass_through_args{end+1} = curr_opt_name;
						if ~ischar(varargin{option_counter+1})
							pass_through_args{end+1} = varargin{option_counter+1};
							option_counter = option_counter+1;
						end
				end
			end
			
			
			
			if this.is_real
				[this.rays, this.multiplicities, this.aux_data] = decompose_tropical_real_curve('input',inputfilename,pass_through_args{:});
			else
				[this.rays, this.multiplicities, this.aux_data] = decompose_tropical_complex_curve('input',inputfilename,pass_through_args{:});
			end
			
			
			% sets things like the name of the system, the name of the
			% homogenizing variable, etc.
			set_from_system_file(this,inputfilename);
			
			if this.is_real
				real_text = 'real';
			else
				real_text = 'complex';
			end
			savedfilename = sprintf('tropdecomp_%s_%s_%s',this.system_name,real_text,datestr(now,'yymmddHHMM'));
			S.T = this;  %#ok % don't worry Matlab, it's used.
			save(savedfilename,'-struct', 'S');
		end
		
		
		%% NUM_VARS
		function num = num_vars(this)
		% Get how many variables are in the system
			num = length(this.variables);
		end
		
		
		%% SET_FROM_SYSTEM_FILE
		function this = set_from_system_file(this, system_name)
		% Set a bunch of internal properties by parsing a Bertini input file
			b_input = bertini_input(system_name);
			[this.aux_data.bertini_options, this.variables, this.curve_system, this.subfunctions, this.is_homogenized, this.homogenizing_variable] = binput2tropicalreal(b_input);
		end
		
		%% ISREAL
		function val = isreal(this)
		% Is this curve real?
			val = this.is_real;
		end
		
		%% ISCOMPLEX
		function val = iscomplex(this)
		% Is this curve complex?
			val = ~this.is_real;
		end
		
		
		%% RAY_SUM
		function v = ray_sum(this)
		% RAY_SUM computes the multiplicity-weighted sum of the rays.
		%
		% Curves for which the real decomposition equals the complex
		% decomposition will balance.  That is, for non-homogenized or
		% dehomogenized systems, this should be all zeros.  For homogenized
		% systems, this will be a vector of entries equal to the degree of
		% the curve.  But only for complex curves, and for real curves
		% which have same decomposition as complex.  
		%
		% There's no theoretical prediction regarding what this should be
		% for real curves.
			v = zeros(size(this.rays,1),1);
			for ii = 1:size(this.rays,2)
			v = v + this.rays(:,ii)*this.multiplicities(ii);
			end
		end
		
		%% CENTER_INDICES
		function ind = center_indices(T)
		% CENTER_INDICES gets the indices of the centers of the paths, in the set of intersection points
			ind = cell(1,size(T.rays,2));
			
			for ii = 1:size(T.rays,2)
				for jj = 1:T.multiplicities(ii)
					ind{ii}(jj) = find_same_point(T.aux_data.intersection_points,T.aux_data.corresponding_centers{ii}(:,jj),1e-7);
				end
			end
			
		end
		
		%% CYCLE_NUMBERS
		function cyc = cycle_numbers(T)
		% CYCLE_NUMBERS gets the cycle numbers of the paths
			cyc = cell(1,size(T.rays,2));
			
			for ii = 1:size(T.rays,2)
				for jj = 1:T.multiplicities(ii)
					path_ind = T.aux_data.corresponding_paths{ii}(jj);
					cyc{ii}(jj) = T.aux_data.paths(path_ind).cycle_number;
				end
			end
			
		end
		
		%% PRINT_INTERSECTION
		function print_intersection(T)
		% PRINT_INTERSECTION prints the intersection points to the screen, suitable for LaTeX
			if T.is_homogenized
				I = leading_rescale(real(T.aux_data.intersection_points))';
			else
				I = T.aux_data.intersection_points';
			end
			
			I(abs(I)<1e-10) = 0;
			
			for ii = 1:size(I,1)
				fprintf('(')
				fprintf('%g, ',I(ii,:))
				fprintf('\b\b) & $p_{%i}$ \\\\ \n',ii)
			end
		end
		
		%% PRINT_RAYS
		function print_rays(T)
		% PRINT_RAYS prints the rays to the screen, in a LaTeX table
		
			for ii = 1:size(T.rays,2)
				fprintf('%i & (',T.multiplicities(ii))
				fprintf('%i, ',T.rays(:,ii))
				fprintf('\b\b) \\\\ \n')
			end
		end
		
		%% UNSCALE
		function this = unscale(this, unscaling_function)
		% UNSCALE uses a function handle to change coordinates.
		%
		% For systems which have been scaled, pass in a function handle and unscale

			this.aux_data.intersection_points = unscaling_function(this.aux_data.intersection_points);


			for ii = 1:length(this.aux_data.paths)
				this.aux_data.paths(ii).unscale(unscaling_function);
			end

			for ii = 1:length(this.aux_data.corresponding_centers)
				this.aux_data.corresponding_centers{ii} = unscaling_function(this.aux_data.corresponding_centers{ii});
			end

		end
		
		

		%% ARRANGE
		arrange(this, plot_indices)
		% ARRANGE the rays in a set of coordinate axes.
		%
		%  This code uses internally set variables to control which
		%  coordinates get plotted.
		
		
		%% PLOT_CAUCHY_WALKS
		plot_cauchy_walks(this,varargin)
		% A broken code for plotting the cauchy loops walked during decomposition.
		
		
		%% PLOT
		plot(this,varargin)
		% PLOT override for a tropical curve.  Plots the rays on axes.
		%
		% Try also ARRANGE()
		
		
		%% DEHOMOGENIZE
		this = dehomogenize(this)
		% DEHOMOGENIZE the tropical curve. 
		% This is a destructive process, in the sense that the tropical
		% curve which is dehomogenized is changed (tropical curves in this
		% code are a handle class, and this function doesn't copy it before modifying it.)
		%
		% If you feel this functionality is inappropriate, please contact
		% the author Daniel Brake, and he and you can talk about making
		% changes to better reflect your desired functionality.
		
		
		
		%  Todo: comment this.
		this = rescale(this)
		
		
		
	end
	
	
	
end
